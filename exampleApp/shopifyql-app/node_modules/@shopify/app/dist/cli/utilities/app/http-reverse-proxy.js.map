{"version":3,"file":"http-reverse-proxy.js","sourceRoot":"","sources":["../../../../src/cli/utilities/app/http-reverse-proxy.ts"],"names":[],"mappings":"AAAA,6CAA6C;AAC7C,OAAO,EAAC,gBAAgB,EAAC,MAAM,+BAA+B,CAAA;AAC9D,OAAO,EAAC,IAAI,EAAE,MAAM,EAAS,OAAO,EAAC,MAAM,kBAAkB,CAAA;AAsB7D;;;;;;;;GAQG;AACH,MAAM,CAAC,KAAK,UAAU,+CAA+C,CACnE,SAAiB,EACjB,aAAiC,SAAS,EAC1C,YAAsC,EACtC,mBAA2C;IAE3C,MAAM,MAAM,GAAG,OAAO,CAAC,OAAO,EAAE,CAAA;IAChC,MAAM,SAAS,GAAG,MAAM,OAAO,CAAC,GAAG,CACjC,YAAY,CAAC,GAAG,CAAC,KAAK,EAAE,MAAM,EAAiC,EAAE;QAC/D,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,aAAa,EAAE,CAAA;QAC7C,MAAM,CAAC,QAAQ,CAAC,gBAAgB,EAAE;YAChC,QAAQ,EAAE,oBAAoB,UAAU,EAAE;YAC1C,MAAM,EAAE,MAAM,CAAC,UAAU;YACzB,aAAa,EAAE,MAAM,CAAC,UAAU;YAChC,KAAK,EAAE,KAAK;YACZ,SAAS,EAAE,MAAM,CAAC,SAAS,KAAK,YAAY;YAC5C,YAAY,EAAE;gBACZ,6EAA6E;gBAC7E,wFAAwF;gBACxF,qBAAqB,EAAE,CAAC,YAAY,EAAE,OAAO,EAAE,EAAE;oBAC/C,MAAM,IAAI,GAAG,SAAS,CAAC,OAAO,CAAC,cAAc,EAAE,EAAE,CAAC,CAAA;oBAClD,OAAO,EAAC,GAAG,OAAO,EAAE,IAAI,EAAC,CAAA;gBAC3B,CAAC;aACF;SACF,CAAC,CAAA;QACF,OAAO;YACL,MAAM,EAAE,MAAM,CAAC,SAAS;YACxB,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,EAAE;gBACvC,MAAM,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,UAAU,CAAC,CAAA;YACzD,CAAC;SACF,CAAA;IACH,CAAC,CAAC,CACH,CAAA;IAED,MAAM,aAAa,GAAG,UAAU,IAAI,CAAC,MAAM,IAAI,CAAC,aAAa,EAAE,CAAC,CAAA;IAEhE,MAAM,OAAO,CAAC,GAAG,CAAC;QAChB,MAAM,CAAC,UAAU,CAAC,CAAC,GAAG,SAAS,EAAE,GAAG,mBAAmB,CAAC,EAAE,CAAC,WAAW,EAAE,EAAE;YACxE,WAAW,CAAC,gBAAgB,CAAC,OAAO,EAAE,KAAK,IAAI,EAAE;gBAC/C,MAAM,MAAM,CAAC,KAAK,EAAE,CAAA;YACtB,CAAC,CAAC,CAAA;QACJ,CAAC,CAAC;QACF,MAAM,CAAC,MAAM,CAAC;YACZ,IAAI,EAAE,aAAa;SACpB,CAAC;KACH,CAAC,CAAA;AACJ,CAAC","sourcesContent":["// eslint-disable-next-line import/extensions\nimport {fastifyHttpProxy} from './fastify-http-proxy/index.js'\nimport {port, output, error, fastify} from '@shopify/cli-kit'\nimport {Writable} from 'stream'\n\nexport interface ReverseHTTPProxyTarget {\n  /** The prefix to include in the logs\n   *   [vite] Output coming from Vite\n   */\n  logPrefix: string\n\n  /**\n   * The HTTP path prefix used to match against request and determine if the traffic should be\n   * forwarded to this target\n   */\n  pathPrefix?: string\n  /**\n   * A callback to invoke the process. stdout and stderr should be used\n   * to send standard output and error data that gets formatted with the\n   * right prefix.\n   */\n  action: (stdout: Writable, stderr: Writable, signal: error.AbortSignal, port: number) => Promise<void> | void\n}\n\n/**\n * A convenient function that runs an HTTP server and does path-based traffic forwarding to sub-processes that run\n * an HTTP server. The method assigns a random port to each of the processes.\n * @param tunnelUrl {string} The URL of the tunnel.\n * @param portNumber {number} The port to use for the proxy HTTP server. When undefined, a random port is automatically assigned.\n * @param proxyTargets {ReverseHTTPProxyTarget[]} List of target processes to forward traffic to.\n * @param additionalProcesses {output.OutputProcess[]} Additional processes to run. The proxy won't forward traffic to these processes.\n * @returns {Promise<ReverseHTTPProxy>} A promise that resolves with an interface to get the port of the proxy and stop it.\n */\nexport async function runConcurrentHTTPProcessesAndPathForwardTraffic(\n  tunnelUrl: string,\n  portNumber: number | undefined = undefined,\n  proxyTargets: ReverseHTTPProxyTarget[],\n  additionalProcesses: output.OutputProcess[],\n): Promise<void> {\n  const server = fastify.fastify()\n  const processes = await Promise.all(\n    proxyTargets.map(async (target): Promise<output.OutputProcess> => {\n      const targetPort = await port.getRandomPort()\n      server.register(fastifyHttpProxy, {\n        upstream: `http://localhost:${targetPort}`,\n        prefix: target.pathPrefix,\n        rewritePrefix: target.pathPrefix,\n        http2: false,\n        websocket: target.logPrefix === 'extensions',\n        replyOptions: {\n          // Update `host` header to be tunnelURL when forwarding to extensions binary.\n          // The binary uses this to build extensions URLs and they must use the tunnelURL always.\n          rewriteRequestHeaders: (_originalReq, headers) => {\n            const host = tunnelUrl.replace(/^https?:\\/\\//, '')\n            return {...headers, host}\n          },\n        },\n      })\n      return {\n        prefix: target.logPrefix,\n        action: async (stdout, stderr, signal) => {\n          await target.action(stdout, stderr, signal, targetPort)\n        },\n      }\n    }),\n  )\n\n  const availablePort = portNumber ?? (await port.getRandomPort())\n\n  await Promise.all([\n    output.concurrent([...processes, ...additionalProcesses], (abortSignal) => {\n      abortSignal.addEventListener('abort', async () => {\n        await server.close()\n      })\n    }),\n    server.listen({\n      port: availablePort,\n    }),\n  ])\n}\n"]}